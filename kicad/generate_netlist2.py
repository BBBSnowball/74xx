import skidl
import json
import sys
import os.path
import pprint
import pdb
import xml.etree.ElementTree as ET
import re
import kinet2pcb
import pcbnew
import logging

#from parts import *
from generate_netlist import *

if __name__ == '__main__':
    # arguments:
    # 1. output prefix
    # 2. serv.json: logic primitives and nets, generated by Yosys
    # 3. serv2.net: XML netlist, generated by VPR -> which primitives are part of the same chip
    # 4. serv.place: table of chip positions

    _, output_prefix, json_file, xml_netlist_file, placement_file = sys.argv

    with open(json_file) as f:
        data = json.load(f)

    xml_netlist = ET.parse(xml_netlist_file)
    netlist_rootblock = xml_netlist.getroot()

    clb_placement = []
    with open(placement_file) as f:
        #placement_text = f.read()
        for line in f:
            cells = line.split("\t")
            if len(cells) >= 6 and cells[5][0] == "#":
                clbnum = int(cells[5][1:].strip())
                while len(clb_placement) < clbnum+1:
                    clb_placement.append(None)
                clb_placement[clbnum] = {
                    "one_of_the_names": cells[0],
                    "x": int(cells[1]),
                    "y": int(cells[2]),
                    "subblk": int(cells[3]),
                    "layer": int(cells[4]),
                }

    top = get_toplevel(data)
    nets = create_nets(top)
    cells = top['cells']

    bitval_to_netname = {}
    for k,v in top['netnames'].items():
        if len(v["bits"]) == 1:
            bitval = v["bits"][0]
            if bitval not in ["0", "1", "z", "x"]:
                if bitval not in bitval_to_netname:
                    bitval_to_netname[bitval] = []
                if k not in bitval_to_netname[bitval]:
                    bitval_to_netname[bitval].append(k)
        # What is the correct order? Does it start with MSB or LSB?
        # -> o_dbus_adr has its first two bits as "0" and we only have DFFs for bits 2 to 31 so first is probably LSB
        for i, bitval in enumerate(v["bits"]):
            if bitval not in ["0", "1", "z", "x"]:
                if bitval not in bitval_to_netname:
                    bitval_to_netname[bitval] = []
                name = "%s[%d]" % (k, i)
                if name not in bitval_to_netname[bitval]:
                    bitval_to_netname[bitval].append(name)
    #for bitval,v in bitval_to_netname.items():
    #    print("bit %d is net %s" % (bitval,v))

    cells_by_output_name = {}
    for cellname,v in cells.items():
        for port,direction in v["port_directions"].items():
            if direction == "output":
                for c in v["connections"][port]:
                    for netname in bitval_to_netname[c]:
                        cells_by_output_name[netname] = cellname
    #for k,v in cells_by_output_name.items():
    #    print("net %s is output of cell %s" % (k,v))

    chips = []
    for clb in netlist_rootblock:
        if clb.tag != "block":
            continue

        instance = clb.attrib["instance"]
        mode = clb.attrib["mode"]

        if re.match("\Aio\[\d+\]\Z", instance):
            # let's ignore IOs, for now
            continue
        m = re.match("\Aclb\[(\d+)\]\Z", instance)
        if not m:
            print("WARN: CLB instance name is not as expected!")
            clbnum = 0
            clbinfo = None
        else:
            clbnum = int(m[1])
            if clbnum < len(clb_placement):
                clbinfo = clb_placement[clbnum]
            else:
                print("WARN: CLB number is higher than those in placement file! (%s > %s)" % (clbnum, len(clb_placement)-1))
                clbinfo = None
        if not clbinfo:
            clbinfo = { "x": 0, "y": 0 }

        print("CLB: %s (%s), %r" % (instance, mode, clbinfo))

        parts = []
        for part in clb:
            if part.tag != "block":
                continue
            name = part.attrib["name"]
            print("  part %s: %s" % (part.attrib["instance"], name))
            if name == "open" or mode in ["inpad", "outpad"]:
                pass
            elif name not in cells_by_output_name:
                print("    !! not found in JSON netlist !!")
            else:
                parts.append({"name": name, "name_in_json": cells_by_output_name[name], "info": top['cells'][cells_by_output_name[name]] })

        if len(parts) > 0:
            chips.append({
                "clbnum": clbnum,
                "type": "\\" + mode,
                "x": clbinfo["x"],
                "y": clbinfo["y"],
                "parts": parts,
            })

    for chip in chips:
        create_chips({chip["type"]: [part["info"] for part in chip["parts"]]}, nets)

    if len(chips) != len(all_chips):
        print("ERROR: We expected to create %d chips but there are actually %d chips!" % (len(chips), len(all_chips)))

    #FIXME positions
    #for chip in all_chips:
    #    print(chip.ref)

    #skidl.ERC()
    skidl.generate_netlist(file_=output_prefix+".kicad_net")
    # direct use of kinet2pcb because generate_pcb() is only available in newer skidl (newer than newest release)
    kinet2pcb.kinet2pcb(default_circuit, output_prefix+".kicad_pcb", fp_lib_dirs)
