import skidl
import json
import sys
import os.path
import pprint
import pdb
import xml.etree.ElementTree as ET
import re
import kinet2pcb
import pcbnew
import logging

#from parts import *
from generate_netlist import *

def xy_mm(x, y):
    # Kicad uses nanometers
    mm_to_nm = 1000*1000
    return pcbnew.VECTOR2I(round(x*mm_to_nm), round(y*mm_to_nm))

if __name__ == '__main__':
    # arguments:
    # 1. output prefix
    # 2. serv.json: logic primitives and nets, generated by Yosys
    # 3. serv2.net: XML netlist, generated by VPR -> which primitives are part of the same chip
    # 4. serv.place: table of chip positions

    verbose = bool(int(os.environ.get("VERBOSE", "0")))

    _, output_prefix, json_file, xml_netlist_file, placement_file = sys.argv

    with open(json_file) as f:
        data = json.load(f)

    xml_netlist = ET.parse(xml_netlist_file)
    netlist_rootblock = xml_netlist.getroot()

    clb_placement = []
    with open(placement_file) as f:
        #placement_text = f.read()
        line_no = 0
        for line in f:
            line_no += 1
            cells = line.split("\t")
            if len(cells) >= 7 and cells[1] == "":
                cells = cells[0:1] + cells[2:]
            if len(cells) >= 6 and cells[5][0] == "#":
                clbnum = int(cells[5][1:].strip())
                while len(clb_placement) < clbnum+1:
                    clb_placement.append(None)
                clb_placement[clbnum] = {
                    "one_of_the_names": cells[0],
                    "x": int(cells[1]),
                    "y": int(cells[2]),
                    "subblk": int(cells[3]),
                    "layer": int(cells[4]),
                }
            elif line_no > 5:
                print("WARN: Couldn't parse line in placement file: %r -> %r" % (line, cells))

    top = get_toplevel(data)
    nets = create_nets(top)
    cells = top['cells']

    bitval_to_netname = {}
    for k,v in top['netnames'].items():
        if len(v["bits"]) == 1:
            bitval = v["bits"][0]
            if bitval not in ["0", "1", "z", "x"]:
                if bitval not in bitval_to_netname:
                    bitval_to_netname[bitval] = []
                if k not in bitval_to_netname[bitval]:
                    bitval_to_netname[bitval].append(k)
        # What is the correct order? Does it start with MSB or LSB?
        # -> o_dbus_adr has its first two bits as "0" and we only have DFFs for bits 2 to 31 so first is probably LSB
        for i, bitval in enumerate(v["bits"]):
            if bitval not in ["0", "1", "z", "x"]:
                if bitval not in bitval_to_netname:
                    bitval_to_netname[bitval] = []
                name = "%s[%d]" % (k, i)
                if name not in bitval_to_netname[bitval]:
                    bitval_to_netname[bitval].append(name)
    if verbose:
        for bitval,v in bitval_to_netname.items():
            print("bit %d is net %s" % (bitval,v))

    cells_by_output_name = {}
    for cellname,v in cells.items():
        for port,direction in v["port_directions"].items():
            if direction == "output":
                for c in v["connections"][port]:
                    for netname in bitval_to_netname[c]:
                        cells_by_output_name[netname] = cellname
    if verbose:
        for k,v in cells_by_output_name.items():
            print("net %s is output of cell %s" % (k,v))

    chips = []
    for clb in netlist_rootblock:
        if clb.tag != "block":
            continue

        clb_instance = clb.attrib["instance"]
        mode = clb.attrib["mode"]

        if re.match("\Aio\[\d+\]\Z", clb_instance):
            # let's ignore IOs, for now
            continue
        m = re.match("\Aclb\[(\d+)\]\Z", clb_instance)
        if not m:
            print("WARN: CLB instance name is not as expected!")
            clbnum = 0
            clbinfo = None
        else:
            clbnum = int(m[1])
            if clbnum < len(clb_placement) and clb_placement[clbnum]:
                clbinfo = clb_placement[clbnum]
            else:
                print("WARN: CLB number doesn't exist in placement file! (%s > %s)" % (clbnum, len(clb_placement)-1))
                clbinfo = None
        if not clbinfo:
            clbinfo = { "x": 0, "y": 0 }

        if verbose:
            print("CLB: %s (%s), %r" % (clb_instance, mode, clbinfo))

        parts = []
        for part in clb:
            if part.tag != "block":
                continue
            name = part.attrib["name"]
            if verbose:
                print("  part %s: %s" % (part.attrib["instance"], name))
            if name == "open" or mode in ["inpad", "outpad"]:
                pass
            elif name not in cells_by_output_name:
                print("ERROR: Part not found in JSON netlist: clb=%r, part=%r" % (clb_instance, name))
            else:
                parts.append({"name": name, "name_in_json": cells_by_output_name[name], "info": top['cells'][cells_by_output_name[name]] })

        if len(parts) > 0:
            chips.append({
                "clbnum": clbnum,
                "type": "\\" + mode,
                "x": clbinfo["x"],
                "y": clbinfo["y"],
                "parts": parts,
            })

    for chip in chips:
        create_chips({chip["type"]: [part["info"] for part in chip["parts"]]}, nets)

    #skidl.ERC()
    skidl.generate_netlist(file_=output_prefix+".kicad_net")
    # direct use of kinet2pcb because generate_pcb() is only available in newer skidl (newer than newest release)
    brd_filename = output_prefix + ".kicad_pcb"
    kinet2pcb.kinet2pcb(default_circuit, brd_filename, None)

    if len(chips) != len(all_chips):
        print("ERROR: We expected to create %d chips but there are actually %d chips! Positions will not be updated!" % (len(chips), len(all_chips)))
    else:
        brd = pcbnew.LoadBoard(brd_filename)

        for i in range(len(chips)):
            chip = chips[i]
            fp = brd.FindFootprintByReference(all_chips[i].ref)
            if fp:
                # coordinate 0,0 seems to be bottom-left in place2.png
                # (place3.png is newer than serv.place because vpr has crashed)
                xy = xy_mm(20*chip["x"], -30*chip["y"])
                fp.SetPosition(xy)
            else:
                print("WARN: Couldn't find footprint with ref=%r" % (all_chips[i].ref))
                xy = xy_mm(0, 0)

            # see https://www.atomic14.com/2022/10/24/kicad-python-scripting-cheat-sheet-copy.html
            pcb_txt = pcbnew.PCB_TEXT(brd)
            pcb_txt.SetText(("clb[%d]\n%s" % (chip["clbnum"], chip["type"][1:])) + "".join("\n" + part["name"] for part in chip["parts"]))
            pcb_txt.SetPosition(xy + xy_mm(7.6/2, -1.6))
            pcb_txt.SetHorizJustify(pcbnew.GR_TEXT_H_ALIGN_CENTER)
            pcb_txt.SetVertJustify(pcbnew.GR_TEXT_V_ALIGN_BOTTOM)
            #pcb_txt.Rotate(xy_mm(x, y), text["angle"])
            pcb_txt.SetTextSize(xy_mm(1, 1))
            #pcb_txt.SetLayer(pcbnew.F_SilkS)
            pcb_txt.SetLayer(pcbnew.User_9)
            brd.Add(pcb_txt)

        #pcbnew.Refresh()
        pcbnew.SaveBoard(brd_filename, brd)
